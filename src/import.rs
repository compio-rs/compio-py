// SPDX-License-Identifier: Apache-2.0 OR MulanPSL-2.0
// Copyright 2025 Fantix King

//! Python module import utilities with caching.
//!
//! This module provides macros and functions for efficiently importing Python modules
//! and accessing their attributes with automatic caching using `OnceCell`.
//!
//! # Thread Safety
//!
//! All cached imports and attributes use `OnceCell::sync`, making them safe to access
//! from multiple threads. The first thread to access will perform the import/getattr,
//! and subsequent accesses will use the cached value.
//!
//! # Performance
//!
//! By caching module imports and attribute lookups, this module avoids the overhead
//! of repeated Python import statements and attribute resolution, which can be
//! significant in performance-critical code paths.
//!
//! # Example
//!
//! ```ignore
//! use crate::import::copy_context;
//!
//! Python::attach(|py| {
//!     let ctx = copy_context(py)?;
//!     // Use the context...
//! });
//! ```

use once_cell::sync::OnceCell;
use pyo3::prelude::*;

/// Generates a function that imports a Python module with caching.
///
/// This macro creates a public function that imports the specified Python module
/// on first call and caches it for subsequent calls using a static `OnceCell`.
///
/// # Generated Function Signature
///
/// ```ignore
/// pub fn module_name<'py>(py: Python<'py>) -> PyResult<&'py Bound<'py, PyModule>>
/// ```
///
/// # Arguments
///
/// * `$module_name` - The name of the Python module to import (as an identifier)
///
/// # Example
///
/// ```ignore
/// import!(asyncio);  // Generates: pub fn asyncio(py: Python) -> PyResult<...>
///
/// Python::attach(|py| {
///     let asyncio = asyncio(py)?;
///     // Use the module...
/// });
/// ```
///
/// # Thread Safety
///
/// The generated function is thread-safe. Multiple threads can call it concurrently,
/// and only the first call will perform the actual import.
macro_rules! import {
    ($module_name:ident) => {
        pub fn $module_name<'py>(py: Python<'py>) -> PyResult<&'py Bound<'py, PyModule>> {
            static MODULE: OnceCell<Py<PyModule>> = OnceCell::new();

            MODULE
                .get_or_try_init(|| {
                    PyModule::import(py, stringify!($module_name)).map(|m| m.unbind())
                })
                .map(|m| m.bind(py))
        }
    };
}

/// Retrieves and caches an attribute from a Python module.
///
/// This macro gets an attribute from a previously imported module and caches it
/// using a static `OnceCell`. The first call performs the attribute lookup,
/// and subsequent calls return the cached value.
///
/// # Arguments
///
/// * `$py` - The Python GIL token
/// * `$module_name` - The module function generated by `import!` macro
/// * `$name` - The attribute name as a string literal
///
/// # Returns
///
/// Returns `PyResult<&Bound<PyAny>>` - a reference to the cached attribute.
///
/// # Example
///
/// ```ignore
/// import!(contextvars);
///
/// Python::attach(|py| {
///     let copy_context = getattr!(py, contextvars, "copy_context")?;
///     let ctx = copy_context.call0()?;
/// });
/// ```
///
/// # Thread Safety
///
/// Like `import!`, this macro generates thread-safe code using static `OnceCell`.
///
/// # Note
///
/// Each invocation of this macro creates a separate static variable, so using
/// it multiple times for the same attribute will create multiple caches.
macro_rules! getattr {
    ($py:expr, $module_name:ident, $name:expr) => {{
        static OBJ: OnceCell<Py<PyAny>> = OnceCell::new();
        OBJ.get_or_try_init(|| $module_name($py)?.getattr($name).map(|f| f.unbind()))?
            .bind($py)
    }};
}

import!(contextvars);

/// Returns a copy of the current Python context.
///
/// This function provides cached access to Python's `contextvars.copy_context()`
/// function and calls it to create a snapshot of the current context.
pub fn copy_context(py: Python) -> PyResult<Bound<PyAny>> {
    getattr!(py, contextvars, "copy_context").call0()
}
