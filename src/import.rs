// SPDX-License-Identifier: Apache-2.0 OR MulanPSL-2.0
// Copyright 2025 Fantix King

//! Python module import utilities with caching.
//!
//! This module provides macros and functions for efficiently importing Python modules
//! and accessing their attributes with automatic caching using `OnceCell`.
//!
//! # Thread Safety
//!
//! All cached imports and attributes use `OnceCell::sync`, making them safe to access
//! from multiple threads. The first thread to access will perform the import/getattr,
//! and subsequent accesses will use the cached value.
//!
//! # Performance
//!
//! By caching module imports and attribute lookups, this module avoids the overhead
//! of repeated Python import statements and attribute resolution, which can be
//! significant in performance-critical code paths.
//!
//! # Example
//!
//! ```ignore
//! use crate::import::copy_context;
//!
//! Python::attach(|py| {
//!     let ctx = copy_context(py)?;
//!     // Use the context...
//! });
//! ```

use once_cell::sync::OnceCell;
use pyo3::prelude::*;

/// Generates a function that imports a Python module with caching.
///
/// This macro creates a public function that imports the specified Python module
/// on first call and caches it for subsequent calls using a static `OnceCell`.
///
/// # Generated Function Signature
///
/// ```ignore
/// pub fn module_name<'py>(py: Python<'py>) -> PyResult<&'py Bound<'py, PyModule>>
/// ```
///
/// # Arguments
///
/// * `$module_name` - The name of the Python module to import (as an identifier)
///
/// # Example
///
/// ```ignore
/// import!(asyncio);  // Generates: pub fn asyncio(py: Python) -> PyResult<...>
///
/// Python::attach(|py| {
///     let asyncio = asyncio(py)?;
///     // Use the module...
/// });
/// ```
///
/// # Thread Safety
///
/// The generated function is thread-safe. Multiple threads can call it concurrently,
/// and only the first call will perform the actual import.
macro_rules! import {
    ($module_name:ident) => {
        pub fn $module_name<'py>(py: Python<'py>) -> PyResult<&'py Bound<'py, PyModule>> {
            static MODULE: OnceCell<Py<PyModule>> = OnceCell::new();

            MODULE
                .get_or_try_init(|| {
                    PyModule::import(py, stringify!($module_name)).map(|m| m.unbind())
                })
                .map(|m| m.bind(py))
        }
    };
}

/// Retrieves and caches an attribute from a Python module.
///
/// This macro gets an attribute from a previously imported module and caches it
/// using a static `OnceCell`. The first call performs the attribute lookup,
/// and subsequent calls return the cached value.
///
/// # Arguments
///
/// * `$py` - The Python GIL token
/// * `$module_name` - The module function generated by `import!` macro
/// * `$name` - The attribute name as a string literal
///
/// # Returns
///
/// Returns `PyResult<&Bound<PyAny>>` - a reference to the cached attribute.
///
/// # Example
///
/// ```ignore
/// import!(contextvars);
///
/// Python::attach(|py| {
///     let copy_context = getattr!(py, contextvars, "copy_context")?;
///     let ctx = copy_context.call0()?;
/// });
/// ```
///
/// # Thread Safety
///
/// Like `import!`, this macro generates thread-safe code using static `OnceCell`.
///
/// # Note
///
/// Each invocation of this macro creates a separate static variable, so using
/// it multiple times for the same attribute will create multiple caches.
macro_rules! getattr {
    ($py:expr, $module_name:ident, $name:expr) => {{
        static OBJ: OnceCell<Py<PyAny>> = OnceCell::new();
        OBJ.get_or_try_init(|| super::$module_name($py)?.getattr($name).map(|f| f.unbind()))?
            .bind($py)
    }};
}

/// Creates a module wrapper with standard imports and boilerplate.
///
/// This macro combines the `import!` macro with a module definition that includes
/// the standard `use` statements needed for working with Python objects.
///
/// # Arguments
///
/// * `$module_name` - The name of the Python module to import
/// * `$($item)*` - The module contents (functions, types, etc.)
///
/// # Example
///
/// ```ignore
/// // Without attributes
/// module!(socket {
///     pub fn getaddrinfo(...) -> PyResult<...> { ... }
/// });
///
/// // With attributes (e.g., #[allow(unused)])
/// module!(#[allow(unused)] asyncio {
///     pub fn iscoroutine(py: Python, obj: &Bound<PyAny>) -> PyResult<bool> {
///         getattr!(py, asyncio, "iscoroutine")
///             .call1((obj,))?
///             .extract()
///     }
/// });
/// ```
macro_rules! module {
    ($(#[$attr:meta])* $module_name:ident { $($item:tt)* }) => {
        import!($module_name);

        $(#[$attr])*
        pub mod $module_name {
            use once_cell::sync::OnceCell;
            use pyo3::prelude::*;

            $($item)*
        }
    };
}

module!(#[allow(unused)] asyncio {
    pub fn iscoroutine(py: Python, obj: &Bound<PyAny>) -> PyResult<bool> {
        getattr!(py, asyncio, "iscoroutine")
            .call1((obj,))?
            .extract()
    }

    pub fn future_type(py: Python<'_>) -> PyResult<&Bound<'_, PyAny>> {
        Ok(getattr!(py, asyncio, "Future"))
    }
});

module!(contextvars {
    /// Returns a copy of the current Python context.
    ///
    /// This function provides cached access to Python's `contextvars.copy_context()`
    /// function and calls it to create a snapshot of the current context.
    pub fn copy_context(py: Python) -> PyResult<Bound<PyAny>> {
        getattr!(py, contextvars, "copy_context").call0()
    }
});

module!(socket {
    use pyo3::types::{PyDict, PyTuple};

    pub fn getaddrinfo(
        py: Python,
        args: Py<PyTuple>,
        kwargs: Option<Py<PyDict>>,
    ) -> PyResult<Py<PyAny>> {
        getattr!(py, socket, "getaddrinfo")
            .call(args, kwargs.as_ref().map(|d| d.bind(py)))
            .map(|r| r.unbind())
    }

    pub fn getnameinfo(
        py: Python,
        args: Py<PyTuple>,
        kwargs: Option<Py<PyDict>>,
    ) -> PyResult<Py<PyAny>> {
        getattr!(py, socket, "getnameinfo")
            .call(args, kwargs.as_ref().map(|d| d.bind(py)))
            .map(|r| r.unbind())
    }
});

module!(weakref {
    pub fn weak_key_dict(py: Python) -> PyResult<Bound<PyAny>> {
        getattr!(py, weakref, "WeakKeyDictionary").call0()
    }
});
