# SPDX-License-Identifier: Apache-2.0 OR MulanPSL-2.0
# Copyright 2025 Fantix King

from __future__ import annotations
from collections.abc import Callable, Iterable, Iterator
from typing import Any, Optional, Protocol, TypeAlias, TypeVarTuple, Unpack

import asyncio
import socket
import ssl
import sys
from contextvars import Context

if sys.version_info >= (3, 12):
    from collections.abc import Buffer
else:
    from typing_extensions import Buffer

_Address: TypeAlias = tuple[Any, ...]

class Handle:
    def cancel(self) -> None: ...
    def cancelled(self) -> bool: ...
    def get_context(self) -> Context: ...

class TimerHandle(Handle):
    def when(self) -> float: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: TimerHandle) -> bool: ...
    def __le__(self, other: TimerHandle) -> bool: ...
    def __gt__(self, other: TimerHandle) -> bool: ...
    def __ge__(self, other: TimerHandle) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

_Ts = TypeVarTuple("_Ts")

class CompioLoop:
    def __init__(self) -> None: ...
    def is_running(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def get_driver_type(self) -> str: ...
    # Pretend call_*() methods return asyncio Handles for type checking purposes
    def call_soon(
        self,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.Handle: ...
    def call_at(
        self,
        when: float,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.TimerHandle: ...
    def call_later(
        self,
        delay: float,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.TimerHandle: ...
    def time(self) -> float: ...
    def run_forever(self) -> None: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...
    async def create_socket(
        self,
        family: socket.AddressFamily | int = -1,
        type: socket.SocketKind | int = -1,
        proto: int = -1,
    ) -> Socket: ...

class Socket:
    async def connect(self, address: _Address, /) -> None: ...
    async def recv(self, bufsize: int, flags: int = 0, /) -> bytes: ...
    async def send(self, data: Buffer, flags: int = 0, /) -> int: ...
    async def shutdown(self, how: int, /) -> None: ...
    async def close(self) -> None: ...
    async def start_tls(
        self,
        ssl_context: ssl.SSLContext | RustlsContext | None = None,
        *,
        server_hostname: Optional[str] = None,
    ) -> SSLSocket: ...

class SSLSocket:
    async def recv(self, bufsize: int, flags: int = 0, /) -> bytes: ...
    async def send(self, data: Buffer, flags: int = 0, /) -> int: ...
    async def close(self) -> None: ...
    def negotiated_alpn(self) -> Optional[bytes]: ...
    def __repr__(self) -> str: ...

class RustlsContext:
    def __init__(self) -> None: ...
    @property
    def protocol_versions(self) -> RustlsProtocolVersions: ...
    @protocol_versions.setter
    def protocol_versions(self, versions: Iterable[ssl.TLSVersion]) -> None: ...
    @property
    def alpn_protocols(self) -> Optional[tuple[bytes, ...]]: ...
    @alpn_protocols.setter
    def alpn_protocols(self, protocols: Optional[tuple[bytes, ...]]) -> None: ...
    @alpn_protocols.deleter
    def alpn_protocols(self) -> None: ...
    @property
    def root_cert_store(self) -> RustlsRootCertStore: ...
    @property
    def custom_server_certificate_verifier(self) -> Optional[CustomServerCertificateVerifier]: ...
    @custom_server_certificate_verifier.setter
    def custom_server_certificate_verifier(
        self, verifier: Optional[CustomServerCertificateVerifier]
    ) -> None: ...
    @custom_server_certificate_verifier.deleter
    def custom_server_certificate_verifier(self) -> None: ...
    @property
    def revocation_options(self) -> RustlsRevocationOptions: ...
    def add_server_certificate_pem(
        self,
        certificate_data: str,
        *,
        private_key: Optional[str] = None,
        password: Optional[str | bytes] = None,
        for_dns_name: Optional[str] = None,
    ) -> None: ...

class RustlsProtocolVersions:
    def add(self, version: ssl.TLSVersion) -> None: ...
    def remove(self, version: ssl.TLSVersion) -> None: ...
    def discard(self, version: ssl.TLSVersion) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, version: ssl.TLSVersion) -> bool: ...
    def __iter__(self) -> Iterator[ssl.TLSVersion]: ...
    def __repr__(self) -> str: ...

class RustlsRootCertStore:
    def __len__(self) -> int: ...
    def add_der(self, cert: Buffer) -> None: ...
    def add_pem(self, cert: str) -> None: ...

class CustomServerCertificateVerifier(Protocol):
    def verify_server_cert(
        self,
        end_entity: RustlsServerCertificate,
        intermediates: list[bytes],
        server_name: RustlsServerName,
        ocsp_response: bytes,
        now: RustlsUnixTime,
        /,
    ) -> None: ...

class RustlsServerCertificate:
    def verify_trust_chain(
        self, intermediate_certs: Iterable[bytes], time: RustlsUnixTime
    ) -> None: ...
    def verify_server_name(self, server_name: RustlsServerName) -> None: ...

class RustlsServerName:
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def is_ip_address(self) -> bool: ...
    def is_dns_name(self) -> bool: ...

class RustlsUnixTime:
    def __init__(self) -> None: ...
    def __int__(self) -> int: ...

class RustlsRevocationOptions:
    only_check_end_entity_revocation: bool
    allow_unknown_revocation_status: bool
    enforce_revocation_expiration: bool

    def add_crls_der(self, der: Buffer) -> None: ...
