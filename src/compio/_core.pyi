# SPDX-License-Identifier: Apache-2.0 OR MulanPSL-2.0
# Copyright 2025 Fantix King

from __future__ import annotations
from collections.abc import Callable
from typing import Any, Optional, TypeVarTuple, Unpack

import asyncio
from contextvars import Context

class Handle:
    def cancel(self) -> None: ...
    def cancelled(self) -> bool: ...
    def get_context(self) -> Context: ...

class TimerHandle(Handle):
    def when(self) -> float: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: TimerHandle) -> bool: ...
    def __le__(self, other: TimerHandle) -> bool: ...
    def __gt__(self, other: TimerHandle) -> bool: ...
    def __ge__(self, other: TimerHandle) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

_Ts = TypeVarTuple("_Ts")

class CompioLoop:
    def __init__(self) -> None: ...
    def is_running(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def get_driver_type(self) -> str: ...
    # Pretend call_*() methods return asyncio Handles for type checking purposes
    def call_soon(
        self,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.Handle: ...
    def call_at(
        self,
        when: float,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.TimerHandle: ...
    def call_later(
        self,
        delay: float,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.TimerHandle: ...
    def time(self) -> float: ...
    def run_forever(self) -> None: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...
