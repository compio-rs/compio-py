# SPDX-License-Identifier: Apache-2.0 OR MulanPSL-2.0
# Copyright 2025 Fantix King

from __future__ import annotations
from collections.abc import Callable
from typing import Any, Optional, TypeAlias, TypeVarTuple, Unpack

import asyncio
import socket
import sys
from contextvars import Context

if sys.version_info >= (3, 12):
    from collections.abc import Buffer
else:
    from typing_extensions import Buffer

_Address: TypeAlias = tuple[Any, ...]

class Handle:
    def cancel(self) -> None: ...
    def cancelled(self) -> bool: ...
    def get_context(self) -> Context: ...

class TimerHandle(Handle):
    def when(self) -> float: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: TimerHandle) -> bool: ...
    def __le__(self, other: TimerHandle) -> bool: ...
    def __gt__(self, other: TimerHandle) -> bool: ...
    def __ge__(self, other: TimerHandle) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

_Ts = TypeVarTuple("_Ts")

class CompioLoop:
    def __init__(self) -> None: ...
    def is_running(self) -> bool: ...
    def is_closed(self) -> bool: ...
    def get_driver_type(self) -> str: ...
    # Pretend call_*() methods return asyncio Handles for type checking purposes
    def call_soon(
        self,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.Handle: ...
    def call_at(
        self,
        when: float,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.TimerHandle: ...
    def call_later(
        self,
        delay: float,
        callback: Callable[[Unpack[_Ts]], Any],
        *args: Unpack[_Ts],
        context: Optional[Context] = None,
    ) -> asyncio.TimerHandle: ...
    def time(self) -> float: ...
    def run_forever(self) -> None: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...
    def create_socket(
        self,
        family: socket.AddressFamily | int = -1,
        type: socket.SocketKind | int = -1,
        proto: int = -1,
    ) -> Socket: ...

class Socket:
    async def connect(self, address: _Address, /) -> None: ...
    async def recv(self, bufsize: int, flags: int = 0, /) -> bytes: ...
    async def send(self, data: Buffer, flags: int = 0, /) -> int: ...
    async def shutdown(self, how: int, /) -> None: ...
    async def close(self) -> None: ...
